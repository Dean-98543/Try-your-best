#### [3. Longest Substring Without Repeating Characters](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

Given a string `s`, find the length of the **longest substring** without repeating characters.

**Example 1:**

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Example 2:**

```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:**

```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Example 4:**

```
Input: s = ""
Output: 0
```

**Constraints:**

- `0 <= s.length <= 5 * 104`
- `s` consists of English letters, digits, symbols and spaces.

#### 解法一：暴力滑动窗口法

解题思路：

1. 遍历每个字符，看看以这个字符开头的最长的无重复字符串的长度是多少，就是这个题的答案
2. 这种方法的时间消耗会非常大，时间复杂度可以达到O(n)

Python代码：

```python
 class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
    	if not s:
            return 0
        temp, left, right, max_len = set(), 0, 0, 0
        while left < len(s):
            right = left
            temp.add(s[left])
            while right < len(s)-1 and s[right+1] not in temp:
                temp.add(s[right+1])
                right+=1
            if right!=left:
                max_len = max(max_len, right-left+1)
            else:
                max_len = max(max_len, 1)
            temp.clear()
            left+=1
        return max_len
```

C++代码：

```C++
#include <iostream>
#include <set>
using namespace std;
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size()==0) return 0;
        set<char> temp;
        int max_len = 0, left = 0, right = 0;
        while(left<s.size())
        {
            right = left;
            temp.insert(s[left]);
            while((right<s.size()-1) && (temp.count(s[right+1])==0))
            {
                temp.insert(s[right+1]);
                right+=1;
            }

            if(right!=left)
            {
                max_len = max(max_len, right-left+1);
            }
            else max_len = max(max_len, 1);
            temp.clear();
            left+=1;
        }
        return max_len;
    }
};
```
#### 1.关于异或

1. Python和C++中的异或符号均为`^`

   1. 相同整数（不论正数还是负数）的异或结果为0
   2. 偶数与偶数+1的异或结果为1（相对应的，奇数与奇数-1的异或结果为1），但是偶数与偶数-1的异或结果不确定（相对应的，奇数与奇数+1的异或结果也不确定）
   3. 0与任何正整数或者负整数异或的结果都等于那个数

```python
# Python
print(-1000^-1000)  # 0
print(-312^-311)    # 1
print(45^45)        # 0
print(2^1)          # 3
print(32^31)        # 63
print(32^33)        # 1
```

```c++
// C++
#include <iostream>
using namespace std;
int main()
{
    int a = -1000^-1000;
    int b = -312^-311;
    int c = 45^45;
    int d = 2^1;
    int e = 32^31;
    int f = 32^33;
    cout << "-1000^-1000:" << a <<endl;      // 0
    cout << "-312^-311:" << b <<endl;        // 1
    cout << "45^45:" << c <<endl;            // 0
    cout << "2^1:" << d <<endl;              // 3
    cout << "32^31:" << e <<endl;            // 63
    cout << "32^33:" << f <<endl;            // 1
    system("pause")
        ;
    return 0;
}
```

#### 2.单调栈

```python
// Python3
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # 解法一：单调栈
        dic = {}
        st = []
        N = len(nums2)
        for i in range(N):
            while st and nums2[i]>st[-1]:
                dic[st.pop()] = nums2[i]
            st.append(nums2[i])
        while st:
            dic[st[-1]] = -1
            st.pop()
        res = []
        for num in nums1:
            res.append(dic[num])
        return res
```

```c++
// C++
#include <iostream>
#include <vector>
#include <stack>
#include <unordered_map>
using namespace std;
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack<int> st;
        unordered_map<int, int> dic;
        int N=nums2.size();
        for(int i=0; i<N; i++){
            while(!st.empty() && nums2[i]>st.top()){
                dic[st.top()] = nums2[i];
                st.pop();
            }
            st.push(nums2[i]);
        }
        while(!st.empty()){
            dic[st.top()] = -1;
            st.pop();
        }
        vector<int> res;
        for(auto num: nums1){
            res.push_back(dic[num]);
        }
        return res;
    }
};
```


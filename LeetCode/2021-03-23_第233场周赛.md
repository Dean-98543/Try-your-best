#### [1800. 最大升序子数组和](https://leetcode-cn.com/problems/maximum-ascending-subarray-sum/)

给你一个正整数组成的数组 `nums` ，返回 `nums` 中一个 **升序** 子数组的最大可能元素和。

子数组是数组中的一个连续数字序列。

已知子数组 `[numsl, numsl+1, ..., numsr-1, numsr]` ，若对所有 `i`（`l <= i < r`），`numsi < numsi+1` 都成立，则称这一子数组为 **升序** 子数组。注意，大小为 `1` 的子数组也视作 **升序** 子数组。

**示例 1：**

```
输入：nums = [10,20,30,5,10,50]
输出：65
解释：[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。
```

**示例 2：**

```
输入：nums = [10,20,30,40,50]
输出：150
解释：[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 
```

**示例 3：**

```
输入：nums = [12,17,15,13,10,11,12]
输出：33
解释：[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 
```

**示例 4：**

```
输入：nums = [100,10,1]
输出：100
```

**提示：**

- `1 <= nums.length <= 100`
- `1 <= nums[i] <= 100`

##### 解法一：滑动窗口

1. 这道题是典型的滑动窗口题，跟[674.最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)的思路是一样一样的
2. 我们可以事先定义`l`和`r`指针，其中`l`指针指向一组升序子数组的左边界，`r`指针指向这组升序子数组的右边界，也就是`[l, r]`。同时我们还要定义一个辅助变量`max_sum`，用来存储并更新最大升序子数组的和，同时作为返回值
3. 刚开始的时候`l=0`，同时`r=0`，也就是这两个指针都同时指向`nums[0]`。因为`l`代表的是这组升序子数组的左边界，所以`l`暂时不动，并暂定为这组升序子数组的和为`temp_sum=nums[l]`（因为这时候`l=r`，所以也可以`temp_sum=nums[r]`）。接着我们往右移`r`指针，也就是`r+=1`，然后我们就要判断`nums[r+1]`是否大于当前r指针的数字`nums[r]`：
   - 如果`nums[r]<nums[r+1]`，那说明我们往后找的元素大于当前元素，这两个元素构成了一个升序子数组，所以我们令`r+=1`，使`r`指向我们找到的这个元素，接着我们更新临时的升序子数组和`temp+=nums[r]`。然后我们要继续看下一个元素是否和当前的升序子数组继续构成升序子数组，所以`r`继续右移，直到找到的`nums[r]>=nums[r+1]`，这时候我们的`temp_sum`就是包含`l`指针和`r`指针指向元素（前闭后闭）之和，接着和`max_sum`进行比较并更新即可
   - 但是如果`nums[r]>=nums[r+1]`，那说明这两个元素并不构成升序子数组。也就是`nums[r]`单独构成了一个升序子数组，所以我们要用着单独一个元素构成的升序子数组和和`max_sum`进行比较，然后更新`max_sum`
4. 遍历完元素之后我们返回`max_sum`即可
5. 上述表达有些啰嗦，简而言之就是，`l`指针指向一组升序子数组的左边界，`r`指针指向这组升序子数组的右边界，然后不断往后滑动`r`，维护`[l, r]`窗口内的元素保证升序

```python
class Solution:
    def maxAscendingSum(self, nums: List[int]) -> int:
        N = len(nums)
        l, r = 0, 0
        max_sum = nums[0]
        while r<N:
            temp_sum = nums[l]
            while r+1<N and nums[r]<nums[r+1]:
                r+=1
                temp_sum+=nums[r]
            max_sum = max(max_sum, temp_sum)
            r+=1
            l=r
        return max_sum
```



